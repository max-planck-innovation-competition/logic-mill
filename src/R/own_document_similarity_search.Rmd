---
title: "Own Document Similarity Search API"
author: "Logic Mill"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
---

This API embeds a user-provided document (title and abstract) and searches for similar documents in specified indices, returning the top matches and their similarity scores.

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Set working directory
if (requireNamespace("rstudioapi", quietly = TRUE) && rstudioapi::isAvailable()) {
  setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
}

# Load environment variables
if (file.exists(".env")) {
  readRenviron(".env")
}
API_KEY <- paste('Bearer', Sys.getenv("API_KEY"))
```

```{r message=FALSE}
library(httr)
library(jsonlite)
library(ghql)
library(dplyr)
library(ggplot2)
library(gridExtra)

# API URL and headers
URL <- 'https://api.logic-mill.net/api/v1/graphql/'

# Set up GraphQL client
conn <- GraphqlClient$new(
  url = URL,
  headers = list(Authorization = API_KEY)
)

# Choose model to encode the document: patspecter, specter2 (only for publications) or paecter (only for patents)
DEFAULT_MODEL <- "patspecter"
```

## Define Input Document

```{r}
# Input document to search for similar documents
title <- "Attaining Carnot efficiency with quantum and nanoscale heat engines"
abstract <- "A heat engine operating in the one-shot finite-size regime, where systems composed of a small number of quantum particles interact with hot and cold baths and are restricted to one-shot measurements, delivers fluctuating work. Further, engines with lesser fluctuation produce a lesser amount of deterministic work. Hence, the heat-to-work conversion efficiency stays well below the Carnot efficiency. Here we overcome this limitation and attain Carnot efficiency in the one-shot finite-size regime, where the engines allow the working systems to simultaneously interact with two baths via the semi-local thermal operations and reversibly operate in a one-step cycle. These engines are superior to the ones considered earlier in work extraction efficiency, and, even, are capable of converting heat into work by exclusively utilizing inter-system correlations. We formulate a resource theory for quantum heat engines to prove the results."

# Number of results per document type
amount_results <- 5

# Document types to search
document_types <- c("patents", "publications")
```

## Search for Similar Documents

```{r}
# Build GraphQL query
query <- 'query embedDocumentAndSimilaritySearch($data: [EncodeDocumentPart], $indices: [String], $amount: Int, $model: String!) {
  encodeDocumentAndSimilaritySearch(
    data: $data
    indices: $indices
    amount: $amount
    model: $model
  ) {
    id
    score
    index
    document {
      title
      url
      PatspecterEmbedding
    }
  }
}'

# Build variables for the query
variables <- list(
  model = DEFAULT_MODEL,
  data = list(
    list(key = "title", value = title),
    list(key = "abstract", value = abstract)
  ),
  amount = amount_results,
  indices = document_types
)

# Execute query
new <- Query$new()$query('link', query)
res <- conn$exec(new$link, variables = variables) %>%
    fromJSON(flatten = FALSE)
```

## View Results

```{r}
# Extract documents
documents <- res$data$encodeDocumentAndSimilaritySearch

# Create summary data frame
df <- data.frame(
  id = documents$id,
  score = documents$score,
  index = documents$index,
  title = substr(documents$document$title, 1, 60)
)

print(df)
```

## 2D PCA Scatterplots for Patents and Publications

The following visualizations show the 2D PCA projections of the document embeddings, separated by document type (patents and publications). Each point represents a document, with its ID shown and its similarity score displayed.

```{r fig.width=12, fig.height=5}
# Extract embeddings
embeddings <- do.call(rbind, documents$document$PatspecterEmbedding)
ids <- documents$id
scores <- documents$score
indices <- documents$index

# Perform PCA
pca_result <- prcomp(embeddings, center = TRUE, scale. = FALSE)
X_2d <- pca_result$x[, 1:2]

# Create data frame for plotting
plot_df <- data.frame(
  PC1 = X_2d[, 1],
  PC2 = X_2d[, 2],
  ID = ids,
  Score = scores,
  Index = indices
)

# Create side-by-side plots

# Patents plot
patents_df <- plot_df[plot_df$Index == "patents", ]
p1 <- ggplot(patents_df, aes(x = PC1, y = PC2)) +
  geom_point(size = 4, color = "#1f77b4", alpha = 0.8) +
  geom_text(aes(label = paste0(ID, "\n(", round(Score, 2), ")")), 
            vjust = -0.5, size = 2.5) +
  theme_minimal() +
  labs(title = "2D PCA of Patents Embeddings",
       x = "PCA Component 1", y = "PCA Component 2")

# Publications plot
publications_df <- plot_df[plot_df$Index == "publications", ]
p2 <- ggplot(publications_df, aes(x = PC1, y = PC2)) +
  geom_point(size = 4, color = "#ff7f0e", alpha = 0.8) +
  geom_text(aes(label = paste0(ID, "\n(", round(Score, 2), ")")), 
            vjust = -0.5, size = 2.5) +
  theme_minimal() +
  labs(title = "2D PCA of Publications Embeddings",
       x = "PCA Component 1", y = "PCA Component 2")

grid.arrange(p1, p2, ncol = 2)
```
